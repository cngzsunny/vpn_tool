name: Sync keli Rule and PlugIn Files with debug

on:
  schedule:
    - cron: '0 20 * * *'
  workflow_dispatch:

concurrency:
  group: sync-vpn-tool
  cancel-in-progress: false

jobs:
  sync-files:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare directories
        run: |
          mkdir -p Loon/Rule/keli

      - name: Download keli Rule files with debug
        run: |
          set -x
          base_agent="Loon/912 CFNetwork/3860.300.31 Darwin/25.2.0"
          declare -A rule_files=(
            ["AI.list"]="https://kelee.one/Tool/Loon/Lsr/AI.lsr"
            ["GoogleVoice.list"]="https://rule.kelee.one/Loon/GoogleVoice.lsr"
            ["Global.list"]="https://rule.kelee.one/Loon/Global.lsr"
            ["LAN_SPLITTER"]="https://kelee.one/Tool/Loon/Lsr/LAN_SPLITTER"
            ["REGION_SPLITTER"]="https://kelee.one/Tool/Loon/Lsr/REGION_SPLITTER"
          )
          for file in "${!rule_files[@]}"; do
            url="${rule_files[$file]}"
            output="Loon/Rule/keli/$file"

            echo "----"
            echo "Downloading Rule: $file"
            echo "URL: $url"
            echo "Output: $output"

            # 先获取 HTTP 状态码和部分头信息
            http_code=$(curl -s -o /dev/null -w "%{http_code}" -A "$base_agent" -L --connect-timeout 10 "$url")
            echo "HTTP Status Code: $http_code"

            # 获取响应头（前 20 行）用于分析 Cloudflare challenge
            echo "Response headers (partial):"
            curl -s -D - -o /dev/null -A "$base_agent" -L --connect-timeout 10 "$url" | head -n 20

            # 获取前 500 字符的 body，用于分析是否是 Cloudflare challenge 页面
            echo "Response body snippet (first 500 chars):"
            curl -s -A "$base_agent" -L --connect-timeout 10 "$url" | head -c 500

            # 真正下载文件
            curl -A "$base_agent" -L --retry 3 --retry-delay 5 --connect-timeout 10 "$url" -o "$output"
          done
